extends ../_layouts/page_home.jade

block content
	#application.lge-container
		.row
			.column-3.lge-container
				.div(data-spay="affix", data-offset-top="60", data-offset-bottom="200")
					h4.grey Exploitation
					h4.dark-green Testing
					h4.grey Prevention
					h4.grey Courses
					h4.grey Related Topics
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					.progress
						.progress-bar(role='progressbar', aria-valuenow='30', aria-valuemin='0', aria-valuemax='100', style='width: 30%')
			.column-6
				h2.grey Testing
				br

				p How to test for Cross-Site Scripting. General black-box testing and code review methods.
				br
				hr
				br

				h3.dark-grey How to Test for XSS
				br

				p Cross site scripting (or XSS) is a well known HTML-related security vulnerability that commonly affects Internet clients through XSS vulnerable servers. A XSS bug in a web server allows an attacker to send malicious payload to a victim browser through the vulnerable server. Payloads may also execute in other HTTP clients not necessarily focused at browsing the web as long as they render HTML and execute any execute scripts.

				p Below is a summary of steps needed for testing for XSS bugs

				p
					ul
						li Step 1: Understand XSS attack scenarios
						li Step 2: List high risk componentsandentry points
						li Step 3: Start testing and exploring
						li Step 4: Tune test case data

				br
				h4.dark-grey Step 1: Understand XSS Attack Scenarios

				p There are two types of XSS: reflective and persistent. A reflective XSS bug occurs when the web server takes input from a visitor and automatically sends him back the input without checking if the data inputted contains a script. Thus, the input data is reflected to the visitor and executes at the visitor's browser. 

				p A persistent XSS bug is when a script embedded in malicious data is stored in a persistent store such as database, a file, or other storing mechanism. The malicious data containing a script persists in the server. If the server application takes this stored content and sends it to the client without validating its contents, the script will be executed in the browser. 

				p It is important to understand both XSS attack scenarios to know what to look at when testing.

				br
				h4.dark-grey  Step 2: List High Risk Components and Entry Points

				br
				h5.dark-grey Identify high risk components

				p The next step in testing for XSS bugs is to do an extensive and careful revision of components that take input data from Internet clients and use send it back to the client. In case of large web services, documentation such as design or architectural, if available, become real handy at this point. Testers need to think about what components reflect data to a web client (for reflective XSS) and store data which is later send to a web client (for persistent XSS). Common components that do this include: 

				p
					ul
						li Search web pages
						li Profile-related web pages
						li Web forums
						li Blogs
						li RSS feeds
						li HTML-based help browsers for thick clients 

				br
				h5.dark-grey Look for code that writes HTML responses

				p There are many different scripting functions that append HTML to the server response. Finding the server-side code that writes data out is the first step evaluating and finding potential XSS issues. Functions to write data to a response vary depending on the language and platform you're testing. Be certain that you understand all the relevant functions in the language you're using.

				br
				h5.dark-grey Check for non-validated and unencoded data in responses

				p Next, check what is being output by the mechanisms above. Even if the data written out by an application comes directly from the user and has not been specifically validated for format, if it is appropriately encoded, it can still be safe.  That said, the encoding must take the form of a whitelist of known-safe characters (generally only the alphanumerics), not a blacklist as is commonly attempted.

				br
				h5.dark-grey Match high risk components with entry points

				p Non-validated data comes from all of the application's entry points, not just the web. Be certain to cover all the possible sources of malicious data which might get passed to a client. Common data sources include:

				p
					ul
						li Web forms
						li URL contents
						li Cookie contents
						li Flash parameters
						li SQL database query contents
						li Web service data
						li Graphical User Interface

				p List the high risk variables in the application and their data sources to make sure that they are covered during review and testing.

				br
				h4.dark-grey  Step 3: Start Test and Exploring                                     

				p During this step testing is focused at submitting basic XSS fuzz strings and observing how the application reacts, and then trying to display a simple alert box that proves the existence of an XSS bug.

				br
				h5.dark-grey Start with a simple fuzz string

				p Success in finding XSS bugs depends on whether the tester is able to store or reflect an HTML script in or through the server. In almost all cases scripts are included in between SCRIPT tags (other tags also worked as explained later). During this step, it is recommended to start exploring how the server application's high risk components react to tag related input. A good idea is to start testing a simple fuzz string like this one:

				p Then look for the string XYZ in server's response to see how the server processed the special script related characters. It might turn out that the server uses the string inside of a tag:

				p Continue by modifying the initial string to try displaying an alert. The double quotes of the original fuzz string closed the value property so whatever came before doesn't matter. Also, after the closing parenthesis next to the letter Z the string can be anything. Taking the string can be simplified to this:

				p The server might reply with:

				br
				h5.dark-grey Try to display an alert box

				p The following goal is to execute a script and the easiest script to test is the one shown in the first scenario that displays an alert box. Note that now the tester knows that the malicious sting needs to start with the > character, due to where in the HTML document it will appear:

				p If the server doesn't filter the SCRIPT tags then an alert box will appear. The code sent back to the tester will look like this.

				br
				h5.dark-grey Cover different tags

				p Sometimes severs filter out the string </script> from their output. If the server doesn't allow script tags, try the img tag and put your code in the src property:

				p In fact, there are many other tags known to be dangerous in some cases, such as --

				p A good choice is to try the following that doesn't require script tags or the JavaScript command:

				br
				h4.dark-grey  Step 4: Tune Test Case Data                                            

				p During this step testing is focused at covering all entry points and tuning test case data based on the format of the specific entry point.  
				
				br
				h5.dark-grey Consider string format and encoding according to entry point

				p The example in step 3 doesn't specify how the fuzz string was passed to the application (it can be assumed that it was through a web form for these purposes). During this step, testers need to go through their list of components and entry points and modify test case data according to the entry point. Make sure that all entry points are covered.
				
				br
				h5.dark-grey Web Forms

				p Web forms are the easiest to test since they commonly allow only ASCII strings. To test through this entry point, just go through the high risk component list looking for ones that have web forms. Then use a web browser to submit test strings to the components via the forms, and possibly an attack proxy like Burp Suite to circumvent any client-side JavaScript used for data validation.

				br
				h5.dark-grey URL Contents

				p A web application is vulnerable to XSS through the value passed in the password variable: 

				p http://www.xvulnerablesite.com/login.asp?username=[value]&password=[value]

				p If testers want to test the following string in the password value: 

				p They will need to modify the above URL in this way:

				p When executing test cases through the URL it is important to try different encodings of the test string. For instance, one can execute the first attack string below and it causes no effect. Then execute the second one and the alert box works. In this case the web application didn't allow the symbol characters (except the round brackets) in ASCII but did in their hexadecimal encodings: 

				p When testing through the URL and sometimes in other places, it is necessary to investigate what type of encodings the server is using and modify test cases according to them.

				br
				h5.dark-grey Cookie contents

				p Sometimes the application blindly displays the contents of a cookie in the web browser. To test the risky component through this entry point we have to modify the cookie file in disk and try to inject a simple script, then restart the browser to see if an alert box appears. Alternately, an attack proxy can be used to perform this modification on the fly, which is especially helpful in the case of complicated applications.

				br
				h5.dark-grey Flash Parameters

				p Since Flash parameters are frequently passed in the URL, testing Flash parameters is similar to testing URL contents. Here, it is necessary to go through each parameter in the URL and see how the application reacts. Flash also frequently receives parameters using FlashVars. Consider the following code to load a Flash movie:

				p During this step, testers will need to change the entry parameters to Flash like this:

				br
				h5.dark-grey Graphical User Interface

				p Testing through the UI is similar to web form testing in that the tester enters test values directly to the screen. In the case of GUI testing the application used is not a web browser but any other application that interacts with high risk components, renders HTML, and that allows user input or otherwise receives untrusted data.

				br
				h5.dark-grey Look for additional entry points

				p Each application has its own set of entry points. This article lists the common ones for XSS attacks. Nonetheless, testers must explore their application for additional ways of passing data that might make it into a XSS vulnerability. It is recommended to use system monitoring tools such as the ones from www.sysinternals.com and dedicated attack tools such as Burp proxy that lets you intercept and add match-and-replace rules to change the contents of HTTP packets.

				br
				h5.dark-grey Keep tuning test cases

				p Sometimes the initial test string can land in a part of the source code where XSS is possible without using a script tag. The tester may be able to pad it a little or maybe just write the JavaScript command. Always check if the initial input lands inside or within an actual command or parameter.

				br
				h5.dark-grey Consider the case of persistent XSS

				p Sometimes the tester won't see the results of test cases right away. An XSS bug might exist that takes malicious input and only sends it back if the attacker does something else like visiting another page, for instance. Such is often the case with a persistent XSS attack.

				p Consider the following case. An application asks for a user's password hint. When the server prompts the user for the hint, the attacker types one of the XSS test strings described before. Then submits the registration but the server doesn't show the alert box. Then the attacker has the victim browse the site's password page and ask for the hint. When the site displays the hint the alert box appears. 

				p While testing persistent XSS, testers must think of all the places where the input might end up and check all of them. They should talk to developers and use specifications to check all data stores where a persistent XSS bug can manifest.

				br
				h4.dark-grey Applies to
				p Applications that manipulate HTML input and output.
				
				br
				h4.dark-grey Conclusions
				p Testing for XSS bugs is not complicated but you need to be thorough. It is important that you go through all the places where your web server renders HTML output. There are many strings to try, many tags to look at, different methods to feed the test data, and even room for automation. However, the most important thing to keep in mind is to follow your test data. Don't just look for the alert box, but look at the code that comes back to you. Successful XSS testing is all about knowing how to tune you test case data.
				
				br
				h4.dark-grey Additional Resources

				p
					:markdown
						* [Cross Site Scripting Cheat Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)
						* [Information about testing applications for Cross-Site Scripting vulnerabilities](http://technet.microsoft.com/library/cc512662.aspx)
						* [Information about fuzz vectors](https://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors)
						* [Information about fuzz testing](http://en.wikipedia.org/wiki/Fuzz_testing)

				br
				hr
				br

				h3.dark-grey ASP.NET All Input Is Validated
				br

				p This Checklist Items can be used to review code to identify potential Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Check For

				p Ensure that all input parameters from form fields, query strings, cookies, and HTTP headers are validated. Validation routines should check for length, range, format, and type. Validation should check first for known valid and safe data and then for malicious, dangerous data.

				br
				h4.dark-grey Why

				p An attacker passing malicious input can attempt SQL injection, cross-site scripting, and other injection attacks that aim to exploit your application's vulnerabilities.

				br
				h4.dark-grey How to Check

				p To check for this problem, use the following steps: 

				p
					ul
						li Find all sources of input. During design time identify all of the potential sources of input parameters to your application. Scour the source code to discover sources of input that may have been missed in the design. Compile a list that you can use in the following steps. The most common sources are:

							p
								ul
									li Form Fields
									li Query Strings
									li Cookies
									li HTTP Headers

						li Trace data from source to sink. Trace each of source of input through your application until you find its ultimate destination. The final sink may be in memory, on the hard drive, sent over the network or stored in a database.

						li Identify validation routines. Each input source should have a data validation routine associated with it. Ideally the validation will occur as soon after the input reaches your application as possible. Shared validation routines are better than creating many spread throughout your code base, check for consolidation of routines to aid testing and reduce the chance of one-off bugs. If an input source does not have a validation routine associated with it, flag it for fixing.

						li Ensure quality of validation routines. Validation routines should check for length, range, format, and type. Validation should check first for known valid and safe data and then for malicious, dangerous data. Do not rely on filtering out all malicious data, it is too easy to miss something. Do not rely on client-side validation alone as it can be easily bypassed.

				br
				h5.dark-grey How to Fix

				p Check for known good data and constrain input by validating it for type, length, format, and range. For Web form applications that obtain input through server controls, use the ASP.NET validator controls, such as the RegularExpressionValidator, RangeValidator, and CustomValidator, to validate and constrain input. Check all numeric fields for type and range. If you are not using server controls, you can use regular expressions and the Regex class, and you can validate numeric ranges by converting the input value to an integer or double and then performing a range check. Validate your input against the least permissive expression possible that will accept all the input you expect for that field. If you know that the field will have certain internal structure, check for it. If your input has an internal checksum, like a credit card number, check that too.

				p Most Web applications accept input from various sources, including HTML controls, server controls, query strings, and cookies. Validate input from all of these sources to help prevent injection attacks. Use regular expressions to help validate input. The following example shows how to use the Regex class.

				p If you cannot cache your regular expression for frequent use, you should use the static IsMatch method where possible for performance reasons, to avoid unnecessary object creation.

				p Remember that validating input does not remove the need to format output, parameterize queries, or otherwise handle user input carefully. 

				br
				hr
				br

				h3.dark-grey ASP.NET Echoed Input Is Encoded
				br

				p This Checklist Items can be used to review code to identify potential Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Check For

				p Ensure that input is not echoed back to the user without first validating and/or encoding the data. Data which can be modified by a user must be treated as untrusted data.

				br
				h4.dark-grey Why

				p Echoing input directly back to the user makes your application susceptible to some code injection attacks, such as Cross-Site Scripting attacks. What constitutes malicious input varies widely depending on the system in question. On the web, it normally means some kind of JavaScript.

				br
				h4.dark-grey How to Check

				p Use the following steps to ensure that input which can be modified by a user is properly validated and encoded before being echoed back to the user:

				p
					ul
						li Identify all sources of user input. At design time and again at the code review stage during development, determine all the possible tainted inputs to the application. Determine the intended characteristics of each input (length, format, etc.) and create validators for them. The following list includes some common input sources:

							p
								ul
									li Form Fields
									li Query strings
									li Databases and data access methods
									li Cookie collection
									li Session and application variables

						li Identify all output that includes user input. At design time and again at the code review stage during development, trace all inputs to the system though and determine all of the places where they may be output. In each case, identify the context in which the output occurs.

						li Ensure all user-controllable data is properly encoded before being sent as output. In each location where data is output, it must be encoded according to the context of the output.

							p
								ul

									li Do not rely on the Server.HtmlEncode function to protect your application against cross-site scripting attacks. Instead use the Microsoft Anti-Cross-Site Scripting Library available here.

									
									li Do not attempt to use a character block list; when taking into account Unicode characters, etc., along with new emerging attack forms, block lists are guaranteed to be ineffective.

									
									li Ensure that allow list encoding is performed so that all non-alphanumeric characters are encoded instead of certain specific characters like '<', '>, etc.

									
									li Encoding must be selected appropriately based upon how the output is returned to the client- either as HTML content or in a URL. Verify the context in which the output is used and ensure it is properly encoded.

									
									li If you are using the Microsoft Anti-Cross-Site Scripting Library, ensure that the Microsoft.Security.Application.AntiXss.HtmlEncode method is being used to encode HTML tags and their attributes. Similarly, in case your application constructs certain URLs from input data or data from a shared database, ensure that the Microsoft.Security.Application.AntiXss.UrlEncode method is being used to make them safe. Whether you are using HttpUtility encoding methods or the methods from the Microsoft AntiXss library, the context matters. HtmlEncode cannot be used in all situations, for example for un-trusted data that is used to create URLs, UrlEncode should be used.

									
									li Make sure that you encode data at the last possible opportunity before the data is returned to the client. If you encode any earlier than this, you may not know the exact context that the data will be used in, and hence the format you need to encode into. Also, early encoding of some data can result in double encoding problems.

									
									li If data is being written out into an HTML context, the following code will ensure that only known safe characters get through and help prevent a large majority of known XSS attacks. It will increase the size of the resulting HTML and does require more processing overhead, but it is definitely safe for use in most scenarios:

				br
				h4.dark-grey How to Fix

				p If you write output that includes user input or data from a shared database or a local file that you do not trust, encode it. Encoding the data ensures that it is treated as literal text and not as script. Use the following guidelines to encode user input:

				p
					ul
						li Do not rely on HtmlEncode. ASP.NET's Server.HtmlEncode function is often used to protect against cross-site scripting attacks. However, this function only encodes <>"& characters. This is not sufficient to protect against all possible attacks.

						li Encode all special characters. The safest solution is to encode all non-alphanumeric characters. Only this type of whitelist solution will catch all possible XSS attacks, regardless of context.  This requires more overhead in terms of processing time and size of the resulting HTML, but it is the safest encoding mechanism for all HTML contexts:

						li Use the Microsoft Anti-XSS Library. If you are using the Anti-Cross Site Scripting Library, you can use the Microsoft.Security.Application.AntiXss.HtmlEncode method. Similarly, if you write URLs that might contain unsafe characters because they have been constructed from input data or data from a shared database, use Microsoft.Security.Application.AntiXss.UrlEncode to make them safe.

						li Note: Make sure that you encode data at the last possible opportunity before the data is returned to the client. If you encode any earlier than this, you may not know the exact context that the data will be used in, and hence the format you need to encode into. Also, early encoding of some data can result in double encoding problems.

				br
				h4.dark-grey Applies to
				p ASP.NET 4.0

				br
				hr
				br

				h3.dark-grey Java All Input Is Validated
				br

				p This Checklist Items can be used to review code to identify potential Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Check For

				p Check for input that has not been passed through a validation routine. All input from external sources should be validated.

				br
				h4.dark-grey Why

				p Input that is not validated can lead to cross-site scripting, SQL injection, directory traversals, and other vulnerabilities which would allow an attacker to gain unauthorized access to sensitive data.

				br
				h4.dark-grey How to Check

				p An application can take input via various ways such as a web interface, database, file system or other software running on the server. Use the following steps to establish a validation strategy:

				p 
					ul
						li Identify all sources of input. At design time identify all potential sources of input to your application. Once implemented, scour source code to discover sources of input that may have been missed in the design. Potential sources of input in a web application typically include:

							p 
								ul
									li URL based parameters
									li Form based parameters
									li Hidden fields
									li Cookies
									li HTTP headers (Host, accept types, www authentication, cache settings, encodings, etc)
									li Local filesystem
									li Database
									li Other services running on the system
									li Javascript variables
									li File upload and attributes (filename, size, data, etc)
									li DNS results or host names
									li External component call return values (COM, AJAX, ActiveX)

						p Once you know the types of input from where your application may receive data, look for all entry points. Good starting points are method parameters and assignment statements. For example:

						p This method uses the searchTerm variable:


						p This assignment stores data from a GET request parameter named index and stores it in the string searchTerm. Ensure that this input is validated:

						p String searchTerm = request.getParameter("index");

						p This assignment uses the input that was gathered above to store more input from a database. Verify that searchTerm is validated before this use, and also ensure that rData is validated as another source of input.

						p double[] rData = common.queryDBForIndex(searchTerm);

						li Trace data from source to sink. Trace each source of input from the immediate source through your application to its final destination. The final sink may be in memory, on the hard drive, sent over the network or stored in a data store such as a database.

						li Identify validation routines. Each input source should have a validation routine associated with it. Ideally the validation will occur as soon as the input reaches your application. Shared validation routines are better than creating many throughout the code base, so check for consolidation of routines to aid testing and reduce the chance of one-off bugs. If any input source does not have a validation routine associated with it, flag it for fixing.

						li Ensure quality of validators. Validation routines should check for length, range, format and type. Validation should first check for good data through whitelisting then for known malicious data through blacklisting. Do not rely on client-side validation alone as it can be bypassed easily.

				br
				h4.dark-grey How to Fix

				p An application can take input via various ways: web interface, database, file system, other software running on the server, etc. Use the following steps to establish a validation strategy:

				p
					ul
						li Establish your application's trust boundary: The notion is that all input not generated by your application is untrusted.

						li Identify all sources of input: An application can have various sources of input and each one is an entry point to your application that can potentially be used to break your application's security model. Enumerate all possible sources of input and make note of the expected input at each source. Potential sources of input in a web application typically include:
		
							p
								ul
									li URL based parameters
									li Form based parameters
									li Hidden fields
									li Cookies
									li HTTP headers
									li Local filesystem
									li Database
									li Other related services

						li Understand the input that your application can handle and process: After identifying the different entry points, define the format and type of input that should be provided through each entry point.

						li Create a set of validators: Build a validator for each format and type of expected input. Centralize your application's validators as it helps strengthen the code by limiting the amount of scattered validation code throughout your application. Place the set of validators on your application's trust boundary. Your application should accept input from the outside world only through its set of validators.

				br
				h5.dark-grey Problem Example

				p The following code produces a data analysis based on a financial index. Unfortunately, the application validates the user's input but not the returned data from the database. Therefore, the application is vulnerable to an integer overflow that can harm the business logic used in generating the data analysis.

				br
				h5.dark-grey Solution Example

				p The following code produces a data analysis based on a financial index. Since the code validates all sources of input to the application, the application is secured from SQL injection and integer overflows. 

				br
				hr
				br

				h3.dark-grey Java Echoed Input Is Encoded
				br

				p This Checklist Items can be used to review code to identify potential Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Check For

				p Ensure that all echoed input is first encoded.

				br
				h4.dark-grey Why

				p Encoding echoed input prevents injection attacks such as cross-site scripting.

				br
				h4.dark-grey How to Check

				p An application can take input via various sources, such as a web interface, database, file system or other software running on the server, and then use that same input in various outputs. Use the following steps to establish a validation strategy:

				p
					ul
						li Identify all sources of input. At design time identify all potential sources of input to your application. Once implemented, scour source code to discover sources of input that may have been missed in the design. Potential sources of input in a web application typically include:
				
							p
								ul
									li URL based parameters
									li Form based parameters
									li Hidden fields
									li Cookies
									li HTTP headers (Host, accept types, www authentication, cache settings, encodings, etc)
									li Local filesystem
									li Database
									li Other services running on the system
									li Javascript variables
									li File upload and attributes (filename, size, data, etc)
									li DNS results or host names
									li External component call return values (COM, AJAX, ActiveX)

							p Once you have listed the sources of input your application can use, look for all entry points. Good starting points are method parameters and assignment statements. For example:

							p This method uses the searchTerm variable.

							p This assignment stores data from a GET request parameter named index and stores it in the string searchTerm. Ensure that this input is validated.

							p This assignment uses the input that was gathered above to store more input from a database. Verify that searchTerm is validated before this use, and also ensure that rData is validated as another source of input.

							li Trace data from source to sink. Trace each source of input from the immediate source, through your application, to its final destination. The final sink may be in memory, on the hard drive, sent over the network or stored in a data store such as a database. Create a list of the input sources that are echoed back to the user through output - whether directly, through a file, in a URL or through a database or other intermediary source.

								p Input used as output may be identified by the following:

								p
									ul
										li out.println()
										li append()
										li insert()
										li write()
										li Assignment operator (=)
										li Increment and assignment operator (+=)
										li Database write operations

							li Ensure input is properly encoded before being used as output. Each of the input sources identified above should have the input encoded properly before it is used as output. Encoding must be selected appropriately based upon how the output is returned to the client. Verify the context in which the output is used and ensure it is properly encoded. A couple example contexts are shown below (URL, HTML entity)

								p
									ul
										li URL Encoding- URLEncoder.encode(output)
										li HTML Entity Encoding - JSP HTML encoding: <c:out value="${output}" />
										li HTML Attribute Encoding
										li JavaScript Encoding
										li CSS Encoding
										li DOM Encoding

								p Beware that certain locations may require a mixed encoding, such as initially performing URL encoding, then performing JavaScript encoding. This depends entirely on the output context wherein the data is used, and requires knowledge of the parsing mechanisms of browsers. Some example encodings are below.

								p User URL provided:

								p No encoding:

								p URL Encoding:

								p HTML Encoding:

				br
				h4.dark-grey How to Fix

				p Encoding the echoed user input prevents injection attacks such as cross-site scripting. Use the following steps to ensure all echoed input is encoded:

				p
					ul
						li Identify all echoed input. Locate all places inside your application where user-supplied data will be returned to the client. Such data can be of a reflective or persistent nature:
		
							p
								ul
									li Reflective: In a reflective setting, the input is immediately returned to the client. For example, search engines present the searched query when displaying the results.
									li Persistent: In a persistent setting, the input is stored and returned to the client when retrieved from the database. For example, message boards store the users' posts inside a database and return them when a given topic is viewed.

						li Determine the type of encoding. After identifying all echoed input, determine how the input is returned to client. Data is said to be in a HTML context when that data is rendered as a part of a HTML document and is understood by the browser to be HTML. There are other contexts available to Web Applications, such as JavaScript context, CSS context, etc. Data is said to be in a JavaScript context when it is included in JavaScript code and is interpreted as JavaScript by the browser, and so on. Data has to be encoded differently for different contexts to prevent Cross-Site Scripting vulnerabilities. The differences of encoding arise from the fact that different contexts have different special symbols and keywords. Output encoding routines have to be designed with the understanding of the context of the output in mind.

							p 

								ul
									li URL encoding: URL encoding allows your application to maintain the original URL, yet display it to the user in a non-malicious way. Because HTTP headers allow a substitution schema, all characters/symbols are preserved by displaying their ASCII codes instead of the actual character/symbol. For example, < is represented by %3C where 3C is the ASCII value for <:

									li HTML encoding: HTML encoding is used when the echoed input is returned as regular text or HTML content. Input should be encoded by substituting certain characters with their respective HTML values:

									li HTML Attribute Encoding: HTML Attribute encoding is used to encode dynamic data that is output in an attribute of an HTML tag, except URL, CSS, and JavaScript event handler attributes.

									li JavaScript Encoding: JavaScript encoding is used to encode dynamic data that is output into the JavaScript context, including certain event handlers in HTML tags.

									li CSS Encoding: CSS encoding is used to encode dynamic data that is output into the CSS context.

									li DOM Encoding: DOM encoding is used to encode dynamic data that is used in situations where the DOM is involved. These instances are more complicated and often involve multiple output contexts, which necessitates chaining in many circumstances.

						li Apply the encoding. After identifying the echoed input and determining the appropriate encoding method, apply the encoding before the input is returned to the client. There are different encoding libraries available. Different libraries have different capabilities and weaknesses. Please, refer to the vendor's documentation for each potential encoding library.

				br
				h4.dark-grey Problem Example

				p The following code produces a data analysis based on a financial index. Because it does not HTML encode the echoed input, the application is vulnerable to reflective cross-site scripting.

				br
				h4.dark-grey Solution Example

				p The following code produces a data analysis based on a financial index. Because the code HTML encodes the echoed input, it is impossible for an attacker to exploit the application via reflective cross-site scripting.

				br
				h4.dark-grey Additional Resources

				p
					ul
						li To learn more about cross-site scripting, including a library to help defend against cross-site scripting attacks, see here.
						li To learn more about cross-site scripting, see here.

				br
				hr
				br

				h3.dark-grey PHP All Input Is Validated
				br

				p This Checklist Items can be used to review code to identify potential Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Check For

				p Verify that white-list/positive input validation is used to filter all user input.

				br
				h4.dark-grey Why

				p Properly implemented input validation is effective at preventing SQL Injection and Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey How to Check

				p To verify that all user input is filtered using white-list input validation:

				p
					ul
						li Identify all entry points for user input. Make a list of all possible sources of user input in your application, such as form fields, POST/GET parameters, cookies, etc.

						li Identify all types on input accepted by the application. For each source of user input on the list, define valid characters, length, format, and range (for numerical values).

						li Identify the input validation subsystem. Verify that validators exist for each type of user input accepted by the application. Make sure that each validator verifies the characters, length, format, and range (for numerical values) of the respective type of input.

				br
				h4.dark-grey How to Fix

				p To validate all user input using white-list input validation:

				p
					ul
						li Identify all entry points for user input. Make a list of all possible sources of user input in your application, such as form fields, POST/GET parameters, cookies, etc.

						li Identify all types on input accepted by the application. For each source of user input on the list, define valid characters, length, format, and range (for numerical values).

						li Define an input validation subsystem. Define a set of validator functions that should be used to validate each type of input handled by the application. Input should be validated on the server.

						li Validate characters. Restrict the acceptable range of characters in text input by using regular expressions.

						li Validate length. Add code to check that the length of the user input is valid.

						li Validate format. If the input type has a specific pattern, such as a date or a phone number, add code to use regular expressions to make sure user input matches the input type specified by the application. Use regular expressions to enforce strong password requirements.

						li Validate range. Restrict the acceptable range of numerical input by comparing the input to the maximum and minimum acceptable values.

						li (Optional) Reject and respond to known bad input. This step does not add much actual security, but it is included here to let you know that such an option exists. The input validation subsystem may check for known attack strings and respond to these likely attacks by doing things like logging detailed user information, alerting the administrator, blocking the user's IP address for some time, and displaying an error message to the attacker informing that you are onto him and reminding him of the consequences.

						li (Optional) Encode input. If the input is going to be displayed back through the web application, consider adding code to encode it to prevent Cross-Site Scripting attacks.


				br
				hr
				br

				h3.dark-grey PHP Echoed Input Is Encoded
				br

				p This Checklist Items can be used to review code to identify potential Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Check For

				p Verify that input that is going to be included in output in HTML contexts is encoded. 

				br
				h4.dark-grey Why

				p Encoding untrusted data before displaying it prevents Cross-Site Scripting vulnerabilities. 

				br
				h4.dark-grey How to Check

				p To check if input included in output is encoded:

				p
					ul
						li Identify all pages that display user entered data. Enumerate all the pages used by the application. Make a list of all the pages that display data that comes from untrusted sources.
						li Identify all user input that is displayed in HTML contexts. For each page that displays untrusted data, make a list of all untrusted data that is displayed and the context in which it is displayed. Most commonly, untrusted data is displayed as HTML. Other possibilities include displaying user input inside JavaScript or CSS.
						li Check the encoding functions for each context. PHP includes functions for encoding HTML and XML special characters. PHP does not include encoding functions for other contexts. If your application displays untrusted data in other contexts, you will need to write your own encoding functions or use a third-party encoding library, such as OWASP ESAPI. Identify these functions within your application and take note if they are not present.
						li Identify functions that display untrusted user data. For each instance of untrusted data being displayed by your application, identify what function outputs that untrusted data. Make a list of these functions and note the code that is directly responsible for displaying untrusted data.
						li Examine the functions that display untrusted user data. Focus on the code that is directly responsible for displaying untrusted data. Make sure that all untrusted data is encoded before being displayed. Make sure that data is encoded using the correct encoding method.

				br
				h4.dark-grey How to Fix

				p To encode PHP input included in output:

				p
					ul
						li Identify all pages that display user entered data. Enumerate all the pages used by the application. Make a list of all the pages that display data that comes from untrusted sources.
						li Identify all user input that is displayed in HTML contexts. For each page that displays untrusted data, make a list of all untrusted data that is displayed and the context in which it is displayed. Most commonly, untrusted data is displayed as HTML. Other possibilities include displaying user input inside JavaScript or CSS.
						li Implement encoding functions for corresponding contexts. PHP has a function for encoding HTML special characters, called htmlspecialchars. PHP does not have encoding functions for data being displayed inside JavaScript and CSS contexts. If your application displays data in contexts other than plain HTML, you will need to write your own encoding functions or use third-party ones. It is recommended to use a third-party encoding library, such as OWASP ESAPI.
						li Identify functions that display untrusted user data. For each instance of untrusted data being displayed by your application, identify what function outputs that untrusted data. Make a list of these functions and note the code that is directly responsible for displaying untrusted data.
						li Add calls to encoding functions to functions that display untrusted data. Add calls to encoding functions in a way that all untrusted data is encoded before being displayed. Make sure that output data is encoded correctly for its respective context.

				br
				h4.dark-grey Additional Resources

				p
					:markdown
						* [Information about htmlspecialchars](http://php.net/manual/en/function.htmlspecialchars.php)
						
				br
				hr
				br

				.row
					.column-3
						a(href='exploitation.html')
							button.btn-action.btn-submit.btn-block(type='button') Exploitation
					.column-offset-6.column-3
						a(href='prevention.html')
							button.btn-action.btn-submit.btn-block(type='button') Prevention
				br
				br