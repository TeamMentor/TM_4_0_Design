extends ../_layouts/page_home.jade

block content
	#application.lge-container
		.row
			.column-3.lge-container
				.div(data-spay="affix", data-offset-top="60", data-offset-bottom="200")
					h4.grey Exploitation
					h4.grey Testing
					h4.dark-green Prevention
					h4.grey Courses
					h4.grey Related Topics
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					br
					.progress
						.progress-bar(role='progressbar', aria-valuenow='50', aria-valuemin='0', aria-valuemax='100', style='width: 50%')
			.column-6
				h2.grey Prevention
				br

				p How to prevent Cross-Site Scripting by writing secure code.
				br
				hr
				br

				h3.dark-grey XSS Prevention Slides
				br

				p These slides are an excerpt from the "Web Vulnerabilities - Threats and Mitigations" course. They describe some measures that help mitigate or prevent Cross-Site Scripting vulnerabilities.

				br
				hr
				br

				h3.dark-grey ASP.NET Validate All Input
				br

				p This Guidance can be used to prevent or fix Cross-Site Scripting vulnerabilities.
				
				br
				h4.dark-grey What to Do

				p Treat input from all external sources as untrusted and apply input validation techniques.

				br
				h4.dark-grey Why

				p Input that is not validated can lead to cross-site scripting, SQL injection, directory traversals, and other vulnerabilities that would allow an attacker to gain unauthorized access to sensitive data or otherwise compromise an application.

				p While input validation can be used to remediate the majority of known security vulnerabilities, it should not be used as the only line of defense, as there are vulnerabilities which input validation is not effective at remediating.

				br
				h4.dark-grey When

				p Treat all input as untrusted. If you have established trust boundaries for your application, validate data every time it crosses a trust boundary.

				br
				h4.dark-grey How

				p An application can take input via various ways: file system, other software running on the server, etc. Use the following steps to establish a validation strategy:

				p
					ul
						li Identify all sources of input: Establish your application's trust boundary. The general notion is that all input not generated by your application is untrusted. Enumerate all possible sources of input and make note of the expected input from these sources. An application can have various sources of input. Each of these sources is an entry point to your application and can potentially be used to break your application's security model. Place a content specific validator at each entry point.

							p
								ul
									li Potential sources of input in a web application typically include:
									li URL based parameters
									li Form based parameters
									li Hidden fields
									li Cookies
									li HTTP headers
									li Data stored on the local file system
									li Database
									li Other related services

						li Understand the input that your application can handle and process: Understand the specifics about your application's input. After identifying the different entry points, define the format and type of input that will be provided through each entry point. Build a validator for every format and type of expected input.

						li Create a set of validators: Centralize your application's validators as it helps strengthen the code by limiting the amount of scattered validation code throughout your application. Place the set of validators on your application's trust boundary. Your application should accept input from the outside world only through its set of validators.

				br
				h4.dark-grey Problem Example

				p In the following code, a page accepts a query string parameter called isbn. The value of this variable is used to look up a book in the database using an unmanaged middle-layer.

				p In this example, the middle layer may be prone to malicious attacks as the value of ISBN is not validated. he length of the string is not limited, which could lead to a buffer overflow in the unmanaged middle layer, and it may not be in the correct format, which could cause a middle layer string parser to crash, allow for format string attacks, SQL injection, or a host of other issues.

				br
				h4.dark-grey Solution Example

				p In the following code, a page accepts a query string parameter called isbn. The value of this variable is used to look up a book in the database using an unmanaged middle layer. The code uses regular expressions to validate the query string string value. This ensures that the value supplied by the client is in the correct format by checking the length of the string and the characters used.

				br
				hr
				br

				h3.dark-grey ASP.NET Encode Echoed Input
				br

				p This Guidance can be used to prevent or fix Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Do

				p Encode user input displayed on pages.

				br
				h4.dark-grey Why

				p Encode user input that is displayed on web pages to prevent Cross-Site Scripting attacks.

				br
				h4.dark-grey When

				p Applications should never echo untrusted or user modifiable data back to the user without appropriate encoding. 

				br
				h4.dark-grey How

				p If you write output that includes user input or data from a shared database or a local file that you do not trust, encode it. Encoding the data ensures that it is treated as literal text and not as script. Use the following guidelines to encode user input:

				p
					ul
						li Do not rely on HtmlEncode. ASP.NET's Server.HtmlEncode function is often used to protect against cross-site scripting attacks. However, this function only encodes <>"& characters. This is not sufficient to protect against all possible attacks.

						li Encode all special characters. The safest solution is to encode all non-alphanumeric characters. Only this type of whitelist solution will catch all possible XSS attacks, regardless of context.  This requires more overhead in terms of processing time and size of the resulting HTML, but it is the safest encoding mechanism for all HTML contexts:

						li Use the Microsoft Anti-XSS Library. If you are using the Anti-Cross Site Scripting Library, you can use the Microsoft.Security.Application.AntiXss.HtmlEncode method. Similarly, if you write URLs that might contain unsafe characters because they have been constructed from input data or data from a shared database, use Microsoft.Security.Application.AntiXss.UrlEncode to make them safe.

						li Note: Make sure that you encode data at the last possible opportunity before the data is returned to the client. If you encode any earlier than this, you may not know the exact context that the data will be used in, and hence the format you need to encode into. Also, early encoding of some data can result in double encoding problems

				br
				hr
				br

				h3.dark-grey Java Validate All Input
				br

				p This Guidance can be used to prevent or fix Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Do

				p Treat input from all external sources as untrusted and apply input validation techniques.

				br
				h4.dark-grey Why

				p Input that is not validated can lead to cross-site scripting, SQL injection, directory traversals, and other vulnerabilities that could allow an attacker to gain unauthorized access to sensitive data.

				br
				h4.dark-grey When

				p Treat all input as untrusted. If you have established trust boundaries for your application, then validate data every time it crosses a trust boundary.

				br
				h4.dark-grey How

				p An application can take input via various ways: web interface, database, file system, other software running on the server, etc. Use the following steps to establish a validation strategy:

				p
					ul
						li Establish your application's trust boundary: The notion is that all input not generated by your application is untrusted.

						li Identify all sources of input: An application can have various sources of input and each one is an entry point to your application that can potentially be used to break your application's security model. Enumerate all possible sources of input and make note of the expected input at each source. Potential sources of input in a web application typically include:
				
							p
								ul
									li URL based parameters
									li Form based parameters
									li Hidden fields
									li Cookies
									li HTTP headers
									li Local filesystem
									li Database
									li Other related services

						li Understand the input that your application can handle and process: After identifying the different entry points, define the format and type of input that should be provided through each entry point.

						li Create a set of validators: Build a validator for each format and type of expected input. Centralize your application's validators as it helps strengthen the code by limiting the amount of scattered validation code throughout your application. Place the set of validators on your application's trust boundary. Your application should accept input from the outside world only through its set of validators.

				br
				h4.dark-grey Problem Example

				p The following code produces a data analysis based on a financial index. Unfortunately, the application validates the user's input but not the returned data from the database. Therefore, the application is vulnerable to an integer overflow that can harm the business logic used in generating the data analysis.

				br
				h4.dark-grey Solution Example

				p The following code produces a data analysis based on a financial index. Since the code validates all sources of input to the application, the application is secured from SQL injection and integer overflows. 

				br
				hr
				br

				h3.dark-grey Java Encode Echoed Input
				br

				p This Guidance can be used to prevent or fix Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Do

				p Encode all input that is displayed back to the user.

				br
				h4.dark-grey Why

				p Proper encoding of echoed input prevents injection attacks such as cross-site scripting.

				br
				h4.dark-grey When

				p If user input will be echoed back to the client in any way, encode it before displaying it. This includes input that is immediately echoed back as well as input that is stored first (such as in a database) before being echoed back later.

				br
				h4.dark-grey How

				p Encoding the echoed user input prevents injection attacks such as cross-site scripting. Use the following steps to ensure all echoed input is encoded:

				p
					ul
						li Identify all echoed input. Locate all places inside your application where user-supplied data will be returned to the client. Such data can be of a reflective or persistent nature:
						
							p
								ul
									li Reflective: In a reflective setting, the input is immediately returned to the client. For example, search engines present the searched query when displaying the results.
						
									li Persistent: In a persistent setting, the input is stored and returned to the client when retrieved from the database. For example, message boards store the users' posts inside a database and return them when a given topic is viewed.

						li Determine the type of encoding. After identifying all echoed input, determine how the input is returned to client. Data is said to be in a HTML context when that data is rendered as a part of a HTML document and is understood by the browser to be HTML. There are other contexts available to Web Applications, such as JavaScript context, CSS context, etc. Data is said to be in a JavaScript context when it is included in JavaScript code and is interpreted as JavaScript by the browser, and so on. Data has to be encoded differently for different contexts to prevent Cross-Site Scripting vulnerabilities. The differences of encoding arise from the fact that different contexts have different special symbols and keywords. Output encoding routines have to be designed with the understanding of the context of the output in mind.

							p
								ul
									li URL encoding: URL encoding allows your application to maintain the original URL, yet display it to the user in a non-malicious way. Because HTTP headers allow a substitution schema, all characters/symbols are preserved by displaying their ASCII codes instead of the actual character/symbol. For example, < is represented by %3C where 3C is the ASCII value for <:

									li HTML encoding: HTML encoding is used when the echoed input is returned as regular text or HTML content. Input should be encoded by substituting certain characters with their respective HTML values:

									li HTML Attribute Encoding: HTML Attribute encoding is used to encode dynamic data that is output in an attribute of an HTML tag, except URL, CSS, and JavaScript event handler attributes.

									li JavaScript Encoding: JavaScript encoding is used to encode dynamic data that is output into the JavaScript context, including certain event handlers in HTML tags.

									li CSS Encoding: CSS encoding is used to encode dynamic data that is output into the CSS context.

									li DOM Encoding: DOM encoding is used to encode dynamic data that is used in situations where the DOM is involved. These instances are more complicated and often involve multiple output contexts, which necessitates chaining in many circumstances.

						li Apply the encoding. After identifying the echoed input and determining the appropriate encoding method, apply the encoding before the input is returned to the client. There are different encoding libraries available. Different libraries have different capabilities and weaknesses. Please, refer to the vendor's documentation for each potential encoding library.

				br
				h4.dark-grey Problem Example

				p The following code produces a data analysis based on a financial index. Because it does not HTML encode the echoed input, the application is vulnerable to reflective cross-site scripting.

				br
				h4.dark-grey Solution Example

				p The following code produces a data analysis based on a financial index. Because the code HTML encodes the echoed input, it is impossible for an attacker to exploit the application via reflective cross-site scripting.

				br
				h4.dark-grey Additional Resources

				p
					:markdown
						* [Learn more about preventing cross-site scripting](http://support.microsoft.com/kb/252985)

				br
				hr
				br

				h3.dark-grey PHP Validate All Input
				br

				p This Guidance can be used to prevent or fix Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Do

				p Validate all user input by using white-list/positive input validation. White-list input validation means allowing only input that is explicitly defined as valid, as opposed to black-list input validation, which filters out known bad input.

				br
				h4.dark-grey Why

				p Properly implemented input validation is effective at preventing SQL Injection and Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey How

				p To validate all user input using white-list input validation:

				p
					ul
						li Identify all entry points for user input. Make a list of all possible sources of user input in your application, such as form fields, POST/GET parameters, cookies, etc.

						li Identify all types on input accepted by the application. For each source of user input on the list, define valid characters, length, format, and range (for numerical values).

						li Define an input validation subsystem. Define a set of validator functions that should be used to validate each type of input handled by the application. Input should be validated on the server.

						li Validate length. Add code to check that the length of the user input is valid.

						li Validate characters. Restrict the acceptable range of characters in text input by using regular expressions.

						li Validate format. If the input type has a specific pattern, such as a date or a phone number, add code to use regular expressions to make sure user input matches the input type specified by the application. Use regular expressions to enforce strong password requirements.

						li Validate range. Restrict the acceptable range of numerical input by comparing the input to the maximum and minimum acceptable values.

						li (Optional) Reject and respond to known bad input. This step does not add much actual security, but it is included here to let you know that such an option exists. The input validation subsystem may check for known attack strings and respond to these likely attacks by doing things like logging detailed user information, alerting the administrator, blocking the user's IP address for some time, and displaying an error message to the attacker informing that you are onto him and reminding him of the consequences.

						li (Optional) Encode input. If the input is going to be displayed back through the web application, consider adding code to encode it to prevent Cross-Site Scripting attacks.

				br
				hr
				br

				h3.dark-grey PHP Encode Echoed Input
				br

				p This Guidance can be used to prevent or fix Cross-Site Scripting vulnerabilities.

				br
				h4.dark-grey What to Do

				p Encode untrusted user data that is going to be included in HTML output. It is recommended to encode user data right before displaying it in HTML contexts. Another option is to encode user data when it is stored. 

				br
				h4.dark-grey Why

				p Encoding untrusted data before displaying it prevents Cross-Site Scripting vulnerabilities. 

				br
				h4.dark-grey How

				p To encode PHP input included in output:

				p
					ul
						li Identify all pages that display user entered data. Enumerate all the pages used by the application. Make a list of all the pages that display data that comes from untrusted sources.
						li Identify all user input that is displayed in HTML contexts. For each page that displays untrusted data, make a list of all untrusted data that is displayed and the context in which it is displayed. Most commonly, untrusted data is displayed as HTML. Other possibilities include displaying user input inside JavaScript or CSS.
						li Implement encoding functions for corresponding contexts. PHP has a function for encoding HTML special characters, called htmlspecialchars. PHP does not have encoding functions for data being displayed inside JavaScript and CSS contexts. If your application displays data in contexts other than plain HTML, you will need to write your own encoding functions or use third-party ones. It is recommended to use a third-party encoding library, such as OWASP ESAPI.
						li Identify functions that display untrusted user data. For each instance of untrusted data being displayed by your application, identify what function outputs that untrusted data. Make a list of these functions and note the code that is directly responsible for displaying untrusted data.
						li Add calls to encoding functions to functions that display untrusted data. Add calls to encoding functions in a way that all untrusted data is encoded before being displayed. Make sure that output data is encoded correctly for its respective context.

				br
				h4.dark-grey Additional Resources

				p
					:markdown
						* [Information about htmlspecialchars](http://php.net/manual/en/function.htmlspecialchars.php)

				br
				hr
				br

				.row
					.column-3
						a(href='testing.html')
							button.btn-action.btn-submit.btn-block(type='button') Testing
					.column-offset-6.column-3
						a(href='courses.html')
							button.btn-action.btn-submit.btn-block(type='button') Courses
				br
				br